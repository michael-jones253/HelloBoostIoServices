
#ifndef __HelloAsio__DgramListener__
#define __HelloAsio__DgramListener__

#include "IoEndPoint.h"

#include <iostream>
#include <ostream>
#include <string>
#include <memory>
#include <vector>
#include <functional>
#if defined(__GNUC__)
/* The classes below are exported */
#pragma GCC visibility push(default)
#endif

namespace AsyncIo
{
	// Hide UDP listener.
	class UdpListener;
	class DgramListener;

	using DgramErrorCallback = std::function<void(std::shared_ptr<DgramListener> listener, const std::string& msg)>;

	using DgramConnectCallback = std::function<void(std::shared_ptr<DgramListener> listener)>;

	using DgramReceiveCallback = std::function<void(std::shared_ptr<DgramListener>, int bytesAvailable)>;

	/// <summary>
	/// Hides the boost implementation of the UDP Listener from the application.
	/// NB this class is generated by IO services methods and not to be instantiated directly by application code.
	/// </summary>
	class DgramListener : public std::enable_shared_from_this<DgramListener>
	{
	private:
		std::weak_ptr<UdpListener> _udpListener;

	public:
		DgramListener(std::shared_ptr<UdpListener> udpListener);

		~DgramListener();

		/// <summary>
		/// Only needed if writing. Once connected to the destination address all async writes go to this address.
		/// </summary>
		/// <param name="connectCb">The connect callback - if unsuccesful the error callback supplied for the bind will be called.</param>
		/// <param name="destIp">The destination ip in dot notation form.</param>
		/// <param name="port">Int the destination UDP port.</param>
		void AsyncConnect(DgramConnectCallback&& connectCb, const std::string& destIp, int port);

		/// <summary>
		/// Allows an already bound Listener to join a multicast group for receiving multicast messages.
		/// </summary>
		/// <param name="multicastAddr">The multicast IP address in dot notation.</param>
		void JoinMulticastGroup(const std::string& multicastAddr);

		/// <summary>
		/// Allows an already bound Listener to send on the broadcast address.
		/// </summary>
		void EnableBroadcast();

		/// <summary>
		/// Asynchronous write of a string message.
		/// NB if the length of the message is greater than MTU it will be split across datagrams.
		/// </summary>
		/// <param name="msg">The string message to send.</param>
		/// <param name="nullTerminate">Whether to null terminate the string or not.</param>
		void AsyncWrite(std::string&& msg, bool nullTerminate);

		/// <summary>
		/// Datagram send for unconnected socket.
		/// </summary>
		/// <param name="msg">The message to send.</param>
		/// <param name="destIp">The destination IP address in dot format.</param>
		/// <param name="port">The destination port.</param>
		/// <param name="nullTerminate">Whether to null terminate the string or not.</param>
		void AsyncSendTo(std::string&& msg, const std::string& destIp, int port, bool nullTerminate);

		/// <summary>
		/// Datagram send for unconnected socket.
        /// More efficient than the methods that take string dot notation
        /// destinations for repeated sends to the same end point because
        /// it avoids repeatedly parsing a string into IP address.
		/// </summary>
		/// <param name="msg">The message to send.</param>
		/// <param name="dest">The destination end point.</param>
        void AsyncSendTo(std::vector<uint8_t>&& msg, const IoEndPoint& dest);

		/// <summary>
		/// Asynchronous write of a string message.
		/// NB if the length of the message is greater than MTU it will be split across datagrams.
		/// </summary>
		/// <param name="msg">The byte vector message to send.</param>
		void AsyncWrite(std::vector<uint8_t>&& msg);

		/// 		/// <summary>
		/// Consume from the start of the circular buffer and copy to the destination buffer.
		/// </summary>
		/// <param name="buf">The destination buffer.</param>
		/// <param name="len">The length to be copied/extracted.</param>
		void ConsumeInto(uint8_t* buf, int len);

		/// <summary>
		/// Consume from the start of the circular buffer and copy to the back of the destination.
		/// </summary>
		/// <param name="dest">The destination vector.</param>
		/// <param name="len">Length to be consumed/copied.</param>
		void ConsumeTo(std::vector<uint8_t>& dest, int len);

		/// <summary>
		/// Returns a pointer to the start of circular buffer data.
		/// </summary>
		/// <returns>Pointer to received data.</returns>
		const uint8_t* Data() const;

		/// <summary>
		/// Returns the size of the available circular buffer data.
		/// </summary>
		/// <returns>Size of the received data.</returns>
		size_t Size() const;

		void Consume(int len);

		/// <summary>
		/// Stop listening.
		/// </summary>
		void StopListening();

		IoEndPoint GetPeerEndPoint() const;

		bool HasAsyncConnected() const;

		/// <summary>
		/// For Unbound, unconnected listeners.
		/// </summary>
		void LaunchRead();

		/// <summary>
		/// Checks whether the listener is valid or not.
		/// </summary>
		/// <returns>True for whether the listener is valid, false otherwise.</returns>
		bool IsValid() const;
	};
}
#if defined(__GNUC__)
#pragma GCC visibility pop
#endif

#endif /* defined(__HelloAsio__DgramListener__) */
